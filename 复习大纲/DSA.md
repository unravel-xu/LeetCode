# 3 列表
## 3-F 循环节
* 由选择排序引入
## 3-G 插入排序
## 3-H 归并排序
## 3-I 逆序对
	统计逆序对个数
## 3-J 游标
* data：记录数据链头
* free：记录空闲链头
# 4 栈和队列
## 4-B 递归相关
### 4-B3 消除递归
* 递归函数的空间复杂度：
	* 主要取决于最大递归深度
	* 而非递归实例总数
### 4-B4 尾递归
* 容易改写为迭代形式（例如 goto 模拟递归返回）
* 空间复杂度可能会有渐进改进
* 时间复杂度可能有常系数改进
## 4-C 进制转换
* 栈：迭代版
* 递归版
## 4-D 括号匹配
* 消除一对紧邻的左右括号，不影响全局的匹配判断
* 顺序扫描，遇到左括号进栈，遇到右括号出栈
## 4-E 栈混洗
* 栈混洗总数：$$SP(n) = \sum^{n}_{k=1}SP(k-1)\cdot SP(n-k)=\frac{(2n)!}{n!(n+1)!}$$
* 禁形："312"
* n 个元素的栈混洗 = n 对括号的匹配
## 4-F 中缀表达式
## 4-G 逆波兰表达式
### 4-G1 求值

| 24  |
| --- |
| 8   |
| 2   |
2 8 24 - + = (8 - 24) + 2 **栈底减（除）栈顶**
### 4-G2 转换
* 手工转化
后缀转中缀
![](Images/Pasted%20image%2020241031095536.png)
中缀转后缀
    加括号，运算符代替右括号，清除左括号
![](Images/Pasted%20image%2020241031095747.png)
* 自动转化
	中缀表达式求值算法附带完成
## 4-H 队列
* 基于向量派生
* 基于列表派生
## 4-J 双栈当队
![|475](Images/1857360-20220714210806132-1672496540.gif)
栈 B 为空时，需先将栈 A 元素转入 B 中，再对栈 B 做 pop
![|475](Images/1857360-20220714210806248-927348673.gif)
## 4-K Steap + Queap
Steap = Stack + Heap = push + pop + getmax
![](Images/Pasted%20image%2020241031110246.png)
* getmax()：return P.top(); // O(1)
* pop()：P.pop(); return S.pop();  //O(1)
* push(): P.push(max(elem, P.top())); S.push(elem);

Queap = Queue + Heap = enqueue + dequeue + getMax
![](Images/Pasted%20image%2020241031112344.png)
* getmax()：return P.front();  // O(1)
* dequeue()：P.dequeue();  return Q.dequeue();  // O(1)
* enqueue()：![|400](Images/Pasted%20image%2020241031113153.png)
  最坏情况需要 O(n)
## 4-L 直方图内最大矩形
[[912 DSA复习笔记##04-L 直方图内最大矩形]]
# 5 二叉树
## 5-A 树
* 节点深度（边数）
	  根节点深度为 0
* 树高度（所有叶子深度中的最大值）
	 空树高度为-1
## 5-B 树的表示
1. 父节点表示法(vector)
2. 孩子节点表示法(vector + list)
3. 父节点+孩子节点(2 * vector + list)
4. 长子+兄弟(2 * pointer)
## 5-C 有根有序树=二叉树
- 深度为 k 的节点，至多有 $2^k$ 个
- 边数 $e = n - 1 = 出度和 = n_{1} + 2n_{2}$
- 节点数 $n = n_{0} + n_{1} + n_{2} = 1 + n_{1} + 2n_{2}$
	$n_{1}+2n_{2} = n-1 = n_{0}+n_{1}+n_{2}-1$
	即叶节点数 $n_{0}=n_{2}+1$
- n 个节点，高度 h 的二叉树满足：$$h + 1 \leq n \leq 2^{h+1} - 1$$
* 满二叉树：$n = 2^{h+1} - 1$
* 真二叉树：引入 $n_{1}+2n_{0}$ 个外部节点，其边数必为偶数，节点数必为奇数
* 完全二叉树：叶节点不少于内部节点，不多于内部节点+1
	满足 $2^h \leq n \leq 2^(h+1)-1$
## 5-D 二叉树实现
* 高度更新
## 5-E 先序遍历
## 5-F 中序遍历
* 直接后继
## 5-G 后序遍历
* 表达式树~后序遍历~RPN
## 5-H 层序遍历
* 完全二叉树做层序遍历，辅助队列最大规模 ($\lceil  \frac{n}{2}  \rceil$，前 $\lceil  \frac{n}{2}  \rceil-1$ 次都出 1 进 2) 可能出现 2 次
## 5-I 重构
- 先序|后序 + 中序
- 先序 + 后序 + 真二叉树
- 增强序列：假想认为树中每个 NULL 也是“真实节点”，并在遍历时一并输出
  1. 任一子树依然对应一个子序列
  2. NULL 节点恰比非 NULL 节点多一个（由此得到左子树根和右子树根）
	则通过先序或后序的增强序列可以重构原树
	无法通过中序的增强序列重构
## 5-J Huffman 树
* PFC 编码（前缀无歧义编码）
  不考虑字符频率，真完全二叉树即最优编码树
- Huffman 树
  频率最低的字符 x、y，必在<font color="#d99694">某棵</font>最优编码树中处于最底层，且互为兄弟
# 6 图
## 6-A 概述
- v-v：邻接    v-e：关联
- 简单图、无向图、有向图、混合图、DAG、MST
- 简单路径：不含重复节点
- 欧拉环路：各边恰好出现一次
- 哈密尔顿环路：各顶点恰好出现一次
## 6-B 邻接矩阵
- 适用于稠密图
- 判边：O(1)
- 获取顶点度数：O(1)
- 添加、删除边后更新度数：O(1)
- 空间：$\Theta(n^2)$
* 平面图：$e \leq 3n-6$
- 压缩存储技术
## 6-C 邻接表
将邻接矩阵的各行组织为列表，只记录存在的边
- 适用于稀疏图
- 空间复杂度：
	有向图：O(n+e)
	无向图：O(n+2e)
	平面图：O(n + 3n) = O(n)
* 时间复杂度：
	建立邻接表：O(n+e)
	遍历所有邻接表：O(n+e)，建立逆邻接表可改进为 O(1+deg(v))
	计算 v 的度数：增加度数记录域：O(n)附加空间
		增加/删除边时更新度数：O(1)
		每次查询：O(1)
	判边：
		有向图：搜索 u 的邻接表 O(deg(u))
		无向图：搜索 u 或 v 的邻接表 O(max(deg(u), deg(v)))
		通过散列：O(1)，增加 O(n+e)的空间
## 6-D BFS
- 时间复杂度：O(n+e)
- 有向图/无向图都会出现 TREE 和 CROSS
UNDISCOVERED：未入队
DISCOVERED：在队列中
VISITED：已出队列
- TREE：v(DISCOVERED)->u(UNDISCOVERED)
- CROSS：v(DISCOVERED)->u(DISCOVERED/VISITED)
对图做 BFS 会生成一个 BFS 森林，包含 c 棵树，n-c 条 TREE（n 个点，如果只有一棵树则有n-1 条边），e-n+c 条 CROSS
- 最短路径：无向图中，顶点 v 到 u 的(最近)距离记作 dist(v, u)
  TREE 联接的顶点：dist(source)恰好差 1
  CROSS 联接的顶点：dist(source)至多差 1
## 6-E DFS
