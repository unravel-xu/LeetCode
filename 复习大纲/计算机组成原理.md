# 1 绪论
## 1.2 计算机系统的基本组成
冯诺依曼结构
	运算器：基本算术运算，逻辑运算，附加运算
	控制器：自动执行指令
	存储器：存放指令和数据（形式上没有区别）
	输入设备
	输出设备
- 核心思想：存储程序工作方式
## 1.3 计算机系统层次结构
ISA（指令集体系结构）处于软件和硬件的交界面
	定义了计算机可以执行的所有指令的集合
	是对硬件的抽象
	所有软件功能都建立在 ISA 之上
## 1.4 程序开发与执行过程
高级语言源代码->（编译程序）汇编语言源程序->（汇编程序）机器语言目标程序->（指令译码器）控制信号
## 1.5 计算机系统性能评价
- (CPU)时钟周期：CPU 主脉冲信号的宽度（用于同步）
- (CPU)时钟频率：时钟周期的倒数
- CPI：执行指令所需时钟周期数
- 程序所含时钟周期数 = 程序所含指令条数 \* CPI = $\sum^{n}_{i=1}CPI_i \times C_i$（n 种不同类型的指令）
- 程序的综合 CPI = $\sum^{n}_{i=1}(CPI_i \times F_i)$ = 程序所含时钟周期数 / 程序所含指令条数
- CPU 执行时间 = 程序所含时钟周期数 / 时钟频率 = 程序所含时钟周期数 \* 时钟周期 = CPI \* 程序总指令条数 \* 时钟周期
两台计算机性能之比=CPU 执行时间之比的倒数
时钟周期、指令条数、CPI 相互制约
## 习题
1. 程序 P 在 M1 上运行需要 10 秒，M1 的时钟频率为 2GHz，M2 与 M1 有相同的 ISA，程序 P 在 M2 上的时钟周期数是在 M1 上的 1.5 倍，则 M2 的时钟频率至少要多少才能使程序 P 在 M2 上的运行时间缩短为 6 秒
> [!hint]-
> P 在 M1 上的时钟周期数 = $10s*2GHz=20G$
> 
> P 在 M2 上的时钟周期数 = $20G*1.5=30G$
> 
> M2 的时钟频率 = $30G \div 6s = 5Ghz$

2. M 的指令集包含 A、B、C 三类指令，其 CPI 分别为 1，2，4。程序 P 在 M 上被编译成两个不同的目标代码序列 P1、P2，分别含 A、B、C 指令条数 8、2、2；2、5、3，请问哪个代码序列指令条数少？哪个执行速度快？它们的 CPI 分别是多少？
>[!hint]- 
> P1 指令条数 = 8 + 2 + 2 = 12
> 
> P2 指令条数 = 2 + 5 + 3 = 10
> 
> P2 指令条数少
> 
> P1 时钟周期数：$8*1+2*2+2*4=20$
> 
> P2 时钟周期数：$2*1+5*2+3*4=24$
> 
> 因为两个序列在同一台机器上运行，所以 CPU 时钟周期一样，P1 时钟周期数少，用时短，执行速度快
> 
> P1 的 CPI = $20 / 12 = 1.67$
> 
> P2 的 CPI = $24 / 10 = 2.4$

3. （2012-912）执行相同程序，以下四个处理器所需要的时间最短的是（）
A：处理器 1 频率为 3 GHz，CPI=1.5
B：处理器 2 频率为 2.5 GHz，CPI=1
C：处理器 3 频率为 4 GHz，CPI=2.2
D：处理器 4 频率为 2.8 GHz，CPI=1.1
> [!hint]-
> D
> 
> 每条指令执行时间 = CPI/CPU频率
> 
> A：0.5
> 
> B：0.4
> 
> C：0.55
> 
> D：0.39...

4. （2018-912）提高 CPU 主频可以加快程序执行速度，CPU 的主频越高，指令执行的越快（）
>[!hint]-
>错误
>
> 三个因素相互制约，提高主频可能导致其他两个因素下降

# 2 数据的机器级表示
## 2.1 数制和编码
- 整数十进制转 R 进制：除到 0，逆向输出余数
- 小数十进制转 R 进制：乘到没有小数（可能小数部分总不为 0），正序输出整数部分
  $0.63*2=1 + 0.26$ -> 1
  $0.26*2 = 0.52$ -> 0
  $0.52 * 2 = 1 + 0.04$ -> 1
  $0.04 * 2 = 0.08$ -> 0
  $0.63 = 0.1010...B$
- 整数+小数分别转化再组合
定点数的编码：
正数的三码都一样
- 原码：0 的表示不唯一
	  加、减运算方式不唯一
	  需额外对符号位处理，不利于硬件设计
	  特别当 a\<b 时，实现 a-b 困难
- 反码：负数返码->符号位不变，数值位取反
	  0 的表示不唯一
	  运算时必须考虑循环进位
- 补码：负数补码->负数的反码+1
	 0 的表示唯一
	 可用加法实现减法运算
	 多表示一个最小负数
	 不需要循环进位调整结果
	 加法运算：符号位和数值位同样计算 $[x+y]_{\text{补}}=[x]_{\text{补}}+[y]_{\text{补}}$
例 $35+(-18)=0010\ 0011+1110 \ 1110 = 1(最高位舍弃)\ 0001 \ 0001 = 0001 \ 0001 = 17$
- 已知补码，求相反数的补码->连同符号位，各位取反，末位加一
例：求 $x_补=1000 \ 0000$ 相反数的补码 
$-x_补 = 0111\ 1111 + 0000\ 0001 = 1\ 0000\ 0000(结果溢出)$，这是由于 +128 无法用补码表示

| 十进制 | 原码                               | 反码                               | 补码                               |
| --- | -------------------------------- | -------------------------------- | -------------------------------- |
| 0   | <font color="#d83931">0</font>00 | <font color="#d83931">0</font>00 | <font color="#d83931">0</font>00 |
| 1   | <font color="#d83931">0</font>01 | <font color="#d83931">0</font>01 | <font color="#d83931">0</font>01 |
| 2   | <font color="#d83931">0</font>10 | <font color="#d83931">0</font>10 | <font color="#d83931">0</font>10 |
| 3   | <font color="#d83931">0</font>11 | <font color="#d83931">0</font>11 | <font color="#d83931">0</font>11 |
| -0  | <font color="#f79646">1</font>00 | <font color="#f79646">1</font>11 | <font color="#d83931">0</font>00 |
| -1  | <font color="#f79646">1</font>01 | <font color="#f79646">1</font>10 | <font color="#f79646">1</font>11 |
| -2  | <font color="#f79646">1</font>10 | <font color="#f79646">1</font>01 | <font color="#f79646">1</font>10 |
| -3  | <font color="#f79646">1</font>11 | <font color="#f79646">1</font>00 | <font color="#f79646">1</font>01 |
| -4  |                                  |                                  | <font color="#f79646">1</font>00                              |
## 2.2 整数的表示
- 无符号整数：默认数的符号为正，所以无符号整数就是非负整数
  表示范围：$0\sim(2^n-1)$
- 有符号整数：用补码表示，表示范围：$-2^{n-1}\sim(2^{n-1}-1)$
## 2.3 实数的表示
浮点数通常表示为：
$N = (-1) ^S \times M \times r^E$
- S：符号位，一般 0 表示正，1 表示负
- r：**基**，可以约定为 2、4、16...
- E：**阶码**，反映浮点数的表示范围和小数点的实际位置
- M：**尾数**，其位数决定了浮点数的有效位数
规格化：使尾数的最高位非 0
	- 左规：$\pm0.001bb\times2^E\to\pm0.1bb\times2^{E-2}$
	- 右规：$\pm 1b.b\times2^E\to\pm0.1bb\times2^{E+2}$
IEEE 754：
![](Images/Pasted%20image%2020241109220016.png)

| 类型   | 数阶  | 阶码  | 尾数数值 | 总位数 | 偏置值  |
| ---- | --- | --- | ---- | --- | ---- |
| 短浮点数 | 1   | 8   | 23   | 32  | 127  |
| 长浮点数 | 1   | 11  | 52   | 64  | 1023 |
隐藏位技术：非 0 值 尾数 规格化后数值的最高位必定为 1(0.1xxx)，通过尾数左移(1.xxx)，强制将该位去掉


