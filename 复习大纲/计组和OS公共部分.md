# 异常和中断
异常：来自 CPU 内部，硬件打断，系统调用以及其他打断程序正常运行流程的事件
中断：异步发生，来自外部设备，不是由专门的指令造成的，而是通过引脚发送信号并将异常号(标识引起中断的设备)放在系统总线上来触发中断
![|500](Images/Pasted%20image%2020241113181120.png)
若异常/中断处理程序能解决问题，则回到第 i 条指令或第 i+1 条指令继续执行
若是不可恢复的致命错误，则终止用户进程，通常具体处理过程全部由 OS 软件完成
各类异常发生的流水段不同，在每条指令执行结束时，会检测有没有中断请求
- IF 检出：无效指令地址
- ID 检出：无效指令、除数为 0
- EXE 检出：溢出，无效数据地址(lw、sw 指令)
相关寄存器：
- 协处理器：处理器的一个<font color="#ff0000">可选</font>部件，负责处理指令集的某个扩展
- CP0：MIPS 的系统控制协处理器，用于处理难以用常规指令解决的问题，CPU 配置，Cache 控制，异常、中断控制、存储管理控制等，包含一系列寄存器
- SR(Status Register)状态寄存器：
	 EXL 段：异常级别，进入内核态，禁止中断
- Cause：导致中断或异常的原因
	  BD 段：是否在延迟槽中
	  IP 段：中断源
	  ExcCode：异常代码
- EPC(Exception Program Counter)异常程序计数器：异常/中断结束后从哪里开始重新执行
	  多周期 CPU：
		  - 中断：指令执行完成后检查中断源，EPC=PC
		  - 异常：指令执行错误后，EPC=上一条指令的地址
	 指令流水 CPU
		 *精确异常*
- 精确异常：在处理异常时，产生异常的位置之前的命令都执行完毕，异常受害指令和其之后的好像从来没有开始一样(异常结束后重新执行，这些指令的行为和异常没有发生时完全一样)，当异常是精确异常时，处理异常的软件就可以忽略 CPU 实现的时序影响。
MIPS 异常处理流程：
1. 保存断点：设置 EPC 指向重新开始的地址
2. 关中断：设置 SR(EXL)位，强制 CPU 进入内核态，并禁用中断
3. 保存异常原因：设置 Cause 寄存器，在地址异常时，BadVAddr 也要设置
4. 从异常入口点取指令，<font color="#ff0000">之后的事情交给软件处理</font>
5. 保存现场：通过 k0 和 k1 寄存器引用一段可以保存其他寄存器的内部空间来实现
6. 读取异常原因，识别中断源：区分不同的异常，Cause 寄存器的 ExcCode 域
7. 构造异常处理内部空间：异常处理程序可能由高级语言编写，需要保留通用寄存器，构造堆、栈存储区
8. 处理异常
9. 恢复现场：恢复寄存器，清零 Cause 寄存器
10. 恢复断点：ERET 指令返回 EPC 指向的地址
11. 开中断：ERET 指令复位 SR(EXL)

异常嵌套：嵌套异常的服务程序必须用一部分主存空间来保存寄存器的值，使用的数据结构叫异常帧，多个嵌套异常的异常帧通常保存在栈中

MIPS 中断控制设计：
- 在中断发生时，如果指令已经完成了 MEM 段的操作，则保证该指令执行完毕
- 否则，丢弃流水线上这条指令的工作