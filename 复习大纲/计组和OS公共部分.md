# 异常和中断
异常：来自 CPU 内部，硬件打断，系统调用以及其他打断程序正常运行流程的事件
中断：异步发生，来自外部设备，不是由专门的指令造成的，而是通过引脚发送信号并将异常号(标识引起中断的设备)放在系统总线上来触发中断
![|500](Images/Pasted%20image%2020241113181120.png)
若异常/中断处理程序能解决问题，则回到第 i 条指令或第 i+1 条指令继续执行
若是不可恢复的致命错误，则终止用户进程，通常具体处理过程全部由 OS 软件完成
各类异常发生的流水段不同，在每条指令执行结束时，会检测有没有中断请求
- IF 检出：无效指令地址
- ID 检出：无效指令、除数为 0
- EXE 检出：溢出，无效数据地址(lw、sw 指令)
- MEM 检出：对只读区域进行写操作的异常等
相关寄存器：
- 协处理器：处理器的一个<font color="#ff0000">可选</font>部件，负责处理指令集的某个扩展
- CP0：MIPS 的系统控制协处理器，用于处理难以用常规指令解决的问题，CPU 配置，Cache 控制，异常、中断控制、存储管理控制等，包含一系列寄存器
- SR(Status Register)状态寄存器：
	 EXL 段：异常级别，进入内核态，禁止中断
- Cause：导致中断或异常的原因
	  BD 段：是否在延迟槽中
	  IP 段：中断源
	  ExcCode：异常代码
- EPC(Exception Program Counter)异常程序计数器：异常/中断结束后从哪里开始重新执行
	  多周期 CPU：
		  - 中断：指令执行完成后检查中断源，EPC=PC
		  - 异常：指令执行错误后，EPC=上一条指令的地址
	 指令流水 CPU
		 *精确异常*
- 精确异常：在处理异常时，产生异常的位置之前的命令都执行完毕，异常受害指令和其之后的好像从来没有开始一样(异常结束后重新执行，这些指令的行为和异常没有发生时完全一样)，当异常是精确异常时，处理异常的软件就可以忽略 CPU 实现的时序影响。
MIPS 异常处理流程：
1. 保存断点：设置 EPC 指向重新开始的地址
2. 关中断：设置 SR(EXL)位，强制 CPU 进入内核态，并禁用中断
3. 保存异常原因：设置 Cause 寄存器，在地址异常时，BadVAddr 也要设置
4. 从异常入口点取指令，<font color="#ff0000">之后的事情交给软件处理</font>
5. 保存现场：通过 k0 和 k1 寄存器引用一段可以<font color="#ff0000">保存其他寄存器</font>的内部空间来实现
6. 读取异常原因，识别中断源：区分不同的异常，Cause 寄存器的 ExcCode 域
7. 构造异常处理内部空间：异常处理程序可能由高级语言编写，需要保留通用寄存器，构造堆、栈存储区
8. 处理异常
9. 恢复现场：恢复寄存器，清零 Cause 寄存器
10. 恢复断点：ERET 指令返回 EPC 指向的地址
11. 开中断：ERET 指令复位 SR(EXL)

异常嵌套：嵌套异常的服务程序必须用一部分主存空间来保存寄存器的值，使用的数据结构叫异常帧，多个嵌套异常的异常帧通常保存在栈中

MIPS 中断控制设计：
- 在中断发生时，如果指令已经完成了 MEM 段的操作，则保证该指令执行完毕
- 否则，丢弃流水线上这条指令的工作

磁盘访问过程：对磁盘的访问总是由缺页引起的
1. CPU 给出地址，需要访问某存储单元
2. 进行 TLB 查找和 cache 查找
3. TLB 查找后声明没有找到
4. 停止并行查找，并通知 OS 处理
5. OS 检查页表，发现缺页
6. OS 从主存中选择一页准备换出
	1. 若换出的页是脏页，需要将其写回磁盘存储
	2. OS 申请 I/O 总线
	3. 获得批准后，发送写命令给 I/O 设备(磁盘)，紧跟着传送需要写回的页的全部数据
	4. I/O 控制器发现发给自己的写命令，加入到握手协议，并接受数据
	5. 根据数据要写入的地址，读/写头移动到正确的柱面，同时将数据接受到缓冲区
	6. 寻道结束后，等待相应的扇区旋转到磁头下，将数据写入扇区中
	7. 在写入数据间隙，计算校验码并写入扇区中
7. OS 继续申请总线(如果还保持总线控制权，则不必申请)
8. 得到授权后，向磁盘发出读命令
9. 然后，磁盘识别地址，并转换为相应的地址段
10. 寻道，将读/写头移动到指定位置
11. 从指定扇区中读取数据，并进行校验
12. 磁盘申请 I/O 总线
13. 得到授权后，将数据通过总线送到内存

# RAID
数据条带化：把一段连续的数据分割成相同大小的数据块，并将其分别写入到阵列中的不同磁盘上，使得多进程可以并发访问
## RAID0
没有冗余，可靠性差，数据条带化
![|500](Images/Pasted%20image%2020241114111702.png)
如果 I/O 请求访问不同盘上的数据，可以并行发送
## RAID1
![](Images/Pasted%20image%2020241114112314.png)
镜像盘实现 1：1 冗余，数据如果条带化，
检错：直接从镜像盘恢复
可靠性高，成本高
## RAID2
![|500](Images/Pasted%20image%2020241114112532.png)
用海明码生成多个冗余校验盘，实现一位纠错，两位检错
七个驱动器的磁头和旋转同步
读：操作性能提高（多盘并行）
写：同时写数据盘和校验盘
## RAID3
![|500](Images/Pasted%20image%2020241114113219.png)
是 RAID2 的简化版本，只对每个字计算一个奇偶校验位
驱动器严格同步，任意一条数据条带内容能从剩余磁盘的相应条带中重新生成
## RAID4
