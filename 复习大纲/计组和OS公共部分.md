# 异常和中断
异常：来自 CPU 内部，硬件打断，系统调用以及其他打断程序正常运行流程的事件
中断：异步发生，来自外部设备，不是由专门的指令造成的，而是通过引脚发送信号并将异常号(标识引起中断的设备)放在系统总线上来触发中断
![|500](Images/Pasted%20image%2020241113181120.png)
若异常/中断处理程序能解决问题，则回到第 i 条指令或第 i+1 条指令继续执行
若是不可恢复的致命错误，则终止用户进程，通常具体处理过程全部由 OS 软件完成
各类异常发生的流水段不同，在每条指令执行结束时，会检测有没有中断请求
- IF 检出：无效指令地址
- ID 检出：无效指令、除数为 0
- EXE 检出：溢出，无效数据地址(lw、sw 指令)
- MEM 检出：对只读区域进行写操作的异常等
相关寄存器：
- 协处理器：处理器的一个<font color="#ff0000">可选</font>部件，负责处理指令集的某个扩展
- CP0：MIPS 的系统控制协处理器，用于处理难以用常规指令解决的问题，CPU 配置，Cache 控制，异常、中断控制、存储管理控制等，包含一系列寄存器
- SR(Status Register)状态寄存器：
	 EXL 段：异常级别，进入内核态，禁止中断
- Cause：导致中断或异常的原因
	  BD 段：是否在延迟槽中
	  IP 段：中断源
	  ExcCode：异常代码
- EPC(Exception Program Counter)异常程序计数器：异常/中断结束后从哪里开始重新执行
	  多周期 CPU：
		  - 中断：指令执行完成后检查中断源，EPC=PC
		  - 异常：指令执行错误后，EPC=上一条指令的地址
	 指令流水 CPU
		 *精确异常*
- BadVaddr Register：访存错误发生时虚拟地址
	  当内存访问出错时保护
	  可用于后续对 TLB 的维护
- 精确异常：在处理异常时，产生异常的位置之前的命令都执行完毕，异常受害指令和其之后的好像从来没有开始一样(异常结束后重新执行，这些指令的行为和异常没有发生时完全一样)，当异常是精确异常时，处理异常的软件就可以忽略 CPU 实现的时序影响。
MIPS 异常处理流程：
1. 保存断点：设置 EPC 指向重新开始的地址
2. 关中断：设置 SR(EXL)位，强制 CPU 进入内核态，并禁用中断
3. 保存异常原因：设置 Cause 寄存器，在地址异常时，BadVAddr 也要设置
4. 从异常入口点取指令，<font color="#ff0000">之后的事情交给软件处理</font>
5. 保存现场：通过 k0 和 k1 寄存器引用一段可以<font color="#ff0000">保存其他寄存器</font>的内部空间来实现
6. 读取异常原因，识别中断源：区分不同的异常，Cause 寄存器的 ExcCode 域
7. 构造异常处理内部空间：异常处理程序可能由高级语言编写，需要保留通用寄存器，构造堆、栈存储区
8. 处理异常
9. 恢复现场：恢复寄存器，清零 Cause 寄存器
10. 恢复断点：ERET 指令返回 EPC 指向的地址
11. 开中断：ERET 指令复位 SR(EXL)

异常嵌套：嵌套异常的服务程序必须用一部分主存空间来保存寄存器的值，使用的数据结构叫异常帧，多个嵌套异常的异常帧通常保存在栈中

MIPS 中断控制设计：
- 在中断发生时，如果指令已经完成了 MEM 段的操作，则保证该指令执行完毕
- 否则，丢弃流水线上这条指令的工作

磁盘访问过程：对磁盘的访问总是由缺页引起的
1. CPU 给出地址，需要访问某存储单元
2. 进行 TLB 查找和 cache 查找
3. TLB 查找后声明没有找到
4. 停止并行查找，并通知 OS 处理
5. OS 检查页表，发现缺页
6. OS 从主存中选择一页准备换出
	1. 若换出的页是脏页，需要将其写回磁盘存储
	2. OS 申请 I/O 总线
	3. 获得批准后，发送写命令给 I/O 设备(磁盘)，紧跟着传送需要写回的页的全部数据
	4. I/O 控制器发现发给自己的写命令，加入到握手协议，并接受数据
	5. 根据数据要写入的地址，读/写头移动到正确的柱面，同时将数据接受到缓冲区
	6. 寻道结束后，等待相应的扇区旋转到磁头下，将数据写入扇区中
	7. 在写入数据间隙，计算校验码并写入扇区中
7. OS 继续申请总线(如果还保持总线控制权，则不必申请)
8. 得到授权后，向磁盘发出读命令
9. 然后，磁盘识别地址，并转换为相应的地址段
10. 寻道，将读/写头移动到指定位置
11. 从指定扇区中读取数据，并进行校验
12. 磁盘申请 I/O 总线
13. 得到授权后，将数据通过总线送到内存

# RAID
数据条带化：把一段连续的数据分割成相同大小的数据块，并将其分别写入到阵列中的不同磁盘上，使得多进程可以并发访问
## RAID0
没有冗余，可靠性差，数据条带化
![|500](Images/Pasted%20image%2020241114111702.png)
如果 I/O 请求访问不同盘上的数据，可以并行发送
## RAID1
镜像盘实现 1：1 冗余，没有数据条带化
![|300](Images/Pasted%20image%2020241114154304.jpg)
写：并行写，受限于写的慢的盘，性能稍微下降
读：提高 2 倍，虽然没有数据条带化，但考虑第一块提供 Block1，第二块提供 Block2
检错：直接从镜像盘恢复
可靠性高，成本高
## RAID2
![|500](Images/Pasted%20image%2020241114112532.png)
工作单位是字/字节
驱动器严格同步
用海明码生成多个冗余校验盘，实现一位纠错，两位检错
读：操作性能提高（多盘并行）
写：同时写数据盘和校验盘
## RAID3
![|500](Images/Pasted%20image%2020241114113219.png)
工作单位是字/字节
驱动器严格同步
是 RAID2 的简化版本，只对每个字计算一个奇偶校验位
读：操作性能提高（多盘并行）
写：同时写数据盘和校验盘
## RAID4
![|500](Images/Pasted%20image%2020241114161803.png)
独立访问
和 RAID0 类似，但和 RAID2、3 区别在于按块校验而不是按位校验
每个磁盘的操作独立进行，可以同时响应多个 I/O 请求
对盘上部分字节数据出错的纠错性能很差
校验盘负载很大
## RAID5
![|500](Images/Pasted%20image%2020241114162619.png)
独立访问
将校验位循环均匀分布到所有的驱动器上
## RAID6
![|500](Images/Pasted%20image%2020241114164202.png)
独立访问
PA：数据块 A 的校验值
P0：第 0 条块的校验值
采用双维块奇偶校验，允许双盘出错
应用于数据绝对不能出错的场合
## RAID7
![|500](Images/Pasted%20image%2020241114164750.jpg)
自身就带有实时操作系统和用于存储管理的软件工具，可完全独立于主机运行
有两个独立的 cache 双工运行，在 Cache 中完成校验
## RAID10
即 RAID1+0
![](Images/Pasted%20image%2020241114112314.png)
# Cache
- 用高速的静态存储器实现
- 完全硬件管理，对程序员透明
块(行)：数据交换的最小单位
失效损失：替换较高层次数据块的时间+将该块交付给处理器的时间
平均访问时间：命中率 \* 命中时间 + (1-命中率) \* 失效损失
## 映射方式
1. 直接映射(只能放固定位置)
![](Images/Pasted%20image%2020241116111947.png)
利用率低，命中率低，效率较低
2. 全相连映射(随意放)
![](Images/Pasted%20image%2020241116113606.png)
只要有空闲行，就不会发生冲突，标志位长，比较电路成本太高
3. 组相联映射(可放到特定分组)
![](Images/Pasted%20image%2020241116113926.png)
## 块替换策略
1. 直接映射
如果对应位置非空，替换
2. 全相联映射
Cache 完全满了才替换，需要在全局选择替换
3. 组相联映射
分组内满了才替换，需要在分组内选择替换

最近最少使用 LRU

FIFO
替换最先被调入 Cache 的块
RAND
随机选择一块替换
## 一致性保证
写命中：
1. 写直达(Write through)
- 写操作时数据既写入 Cache 又写入主存
- 强一致性保证，效率低
	- 写分配法
	- 非写分配
2. 拖后写/写回法(Write back)
- 写操作时只把数据写入 Cache 而不写入主存，当 Cache 数据被替换出去时才写回主存
- 弱一致性保证，效率高
	- 主动替换
	- 被动替换
- 通过监听总线上的访问操作来实现
写不命中：
1. 写分配法
当 CPU 对 Cache 写不命中时，先在主存块中更新相应存储单元，然后分配一个 Cache 行，将更新后的主存块装入到分配的 Cache 行中
2. 非写分配法
当 CPU 对 Cache 写不命中时，只写入主存，不调入 Cache