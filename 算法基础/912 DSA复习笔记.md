# 绪论
## 01-E3递归与迭代：总和最大区段
[53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/) 
````tab
tab: 题目

#中等

描述：给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**子数组**是数组中的一个连续部分。

tab: 示例

**示例 1：**

**输入：**nums = [-2,1,-3,4,-1,2,1,-5,4]

**输出：**6

**解释：**连续子数组 [4,-1,2,1] 的和最大，为 6 。

**示例 2：**

**输入：**nums = [1]

**输出：**1

**示例 3：**

**输入：**nums = [5,4,-1,7,8]

**输出：**23

tab: 思路

A = [-2, 1, 4, -6, 3, 0]，记gs为待求的最大和，从前向后/从后向前考虑都可以，PPT上要求存在多个相同结果时，返回最靠后最短的子数组，所以从后向前考虑。现在从前向后进行分析：A[0]<0，所以gs一定不会包含A[0]；A[1]>0，A[2]>0，此时gs=A[1] + A[2] = 5，A[3] = -6，gs + A[3] = -1 < 0，假设数组自A[3]后存在最大子数组，该最大子数组不会再前伸包含\[A[i]~A[3]\](i=0,1,2)，因为前缀中包含A[3]的最大和为-1<0，只会让gs减小，因此，跳过A[3]，从A[4]开始考虑。

严谨证明见PPT71

tab: 代码

```c++
int gs_LS(int A[], int n) {
	int gs = A[0], s = 0, i = n;
	while(0 < i--){
	    s += A[i]; // 记录部分和
	    if (gs < s) gs = s;
	    if (s <= 0) s = 0; // 舍弃已记录的部分和，从新元素开始
	}
	return gs;
}
```
````
## 01-F1动态规划：斐波那契数
[LCR 126. 斐波那契数](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)
````tab
tab:题目

#简单 #dp

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。

答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

tab:示例

**示例 1：**

**输入：**n = 2
**输出：**1
**解释：**F(2) = F(1) + F(0) = 1 + 0 = 1

**示例 2：**

**输入：**n = 3
**输出：**2
**解释：**F(3) = F(2) + F(1) = 1 + 1 = 2

**示例 3：**

**输入：**n = 4
**输出：**3
**解释：**F(4) = F(3) + F(2) = 2 + 1 = 3

**提示：**

- `0 <= n <= 100`

tab:思路

1. **暴力递归：**

原理： 把 f(n) 问题的计算拆分成 f(n−1) 和 f(n−2) 两个子问题的计算，并递归，以 f(0) 和 f(1) 为终止条件。

缺点： 大量重复的递归计算，例如 f(n) 和 f(n−1) 两者向下递归需要 各自计算 f(n−2) 的值。

2. **记忆化递归：**

原理： 在递归法的基础上，新建一个长度为 n 的数组，用于在递归时存储 f(0) 至 f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。

缺点： 记忆化存储需要使用 O(N) 的额外空间。

3. **动态规划：**

原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1) 为转移方程。
从计算效率、空间复杂度上看，动态规划是本题的最佳解法。

tab:代码

```c++
class Solution {
public:
    int fib(int n) {
        int fib_prev_prev = 0; // 初始为fib(0)，此后保存fib(n-2)
        int fib_prev = 1; // 初始为fib(1)，此后保存fib(n-1)
        int sum; // fib(n)
	    if(n==0||n==1)
	        return n;
	    else{
	        while(1<n--){
	            sum = (fib_prev_prev + fib_prev) % 1000000007; // 此时sum = fib(n)
	            fib_prev_prev = fib_prev; // 更新fib(n-2) = fib(n-1)
	            fib_prev = sum; // 更新fib(n-1) = fib(n)
	        }
	        return sum;
	    }
    }
};
```
````
## 01-F2动态规划：最长公共子序列
[LCR 095. 最长公共子序列](https://leetcode.cn/problems/qJnOS7/)
````tab
tab:题目

#中等

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

tab:示例

**示例 1：**

**输入：**text1 = "abcde", text2 = "ace" 
**输出：**3  
**解释：**最长公共子序列是 "ace" ，它的长度为 3 。

**示例 2：**

**输入：**text1 = "abc", text2 = "abc"
**输出：**3
**解释：**最长公共子序列是 "abc" ，它的长度为 3 。

**示例 3：**

**输入：**text1 = "abc", text2 = "def"
**输出：**0
**解释：**两个字符串没有公共子序列，返回 0 。

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

tab:思路
当text1或text2长度为0时，显然lcs=0，假设我们已经知道text1[0:i-1]和text2[0:j-1]这两个字符串的最长公共子序列，当text1和text2都增加一个字符时，会产生三种情况：
1. text1[i] == text2[j]，则最长公共子序列增加1
2. text1[i] != text2[j]，则最长公共子序列仍有可能增加1，例如 text1 = "acb,d", text2 = "ace,b"，虽然text1增加的字符是'd'不等于text2增加的字符'b'，但text2[j] = 'b'可能与text1[0:i-1]新增匹配，使得lcs+1

状态转移方程：
$$
d p[i][j]= \begin{cases}d p[i-1][j-1]+1, & \operatorname{text}_1[i-1]=\operatorname{text}_2[j-1] \\ \max (d p[i-1][j], d p[i][j-1]), & \operatorname{text}_1[i-1] \neq \operatorname{text}_2[j-1]\end{cases}
$$

tab:代码
```c++
#include <iostream>
#include <string>
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.length();
        int m = text2.length();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(text1[i]==text2[j]){
                    dp[i+1][j+1] = 1+dp[i][j];
                }
                else{
                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]);
                }
            }
        }
        return dp[n][m];
    }
};
```
````
# 二叉树
## 二叉树模板类
