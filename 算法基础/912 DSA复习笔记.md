# 绪论
## 01-E3递归与迭代：总和最大区段
[53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/) 
````tab
tab: 题目

#中等

描述：给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**子数组**是数组中的一个连续部分。

tab: 示例

**示例 1：**

**输入：**nums = [-2,1,-3,4,-1,2,1,-5,4]

**输出：**6

**解释：**连续子数组 [4,-1,2,1] 的和最大，为 6 。

**示例 2：**

**输入：**nums = [1]

**输出：**1

**示例 3：**

**输入：**nums = [5,4,-1,7,8]

**输出：**23

tab: 思路

A = [-2, 1, 4, -6, 3, 0]，记gs为待求的最大和，从前向后/从后向前考虑都可以，PPT上要求存在多个相同结果时，返回最靠后最短的子数组，所以从后向前考虑。现在从前向后进行分析：A[0]<0，所以gs一定不会包含A[0]；A[1]>0，A[2]>0，此时gs=A[1] + A[2] = 5，A[3] = -6，gs + A[3] = -1 < 0，假设数组自A[3]后存在最大子数组，该最大子数组不会再前伸包含\[A[i]~A[3]\](i=0,1,2)，因为前缀中包含A[3]的最大和为-1<0，只会让gs减小，因此，跳过A[3]，从A[4]开始考虑。

严谨证明见PPT71

tab: 代码

```c++
int gs_LS(int A[], int n) {
	int gs = A[0], s = 0, i = n;
	while(0 < i--){
	    s += A[i]; // 记录部分和
	    if (gs < s) gs = s;
	    if (s <= 0) s = 0; // 舍弃已记录的部分和，从新元素开始
	}
	return gs;
}
```
````
## 01-F1动态规划：斐波那契数
[LCR 126. 斐波那契数](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)
````tab
tab:题目

#简单 #dp

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。

答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

tab:示例

**示例 1：**

**输入：**n = 2
**输出：**1
**解释：**F(2) = F(1) + F(0) = 1 + 0 = 1

**示例 2：**

**输入：**n = 3
**输出：**2
**解释：**F(3) = F(2) + F(1) = 1 + 1 = 2

**示例 3：**

**输入：**n = 4
**输出：**3
**解释：**F(4) = F(3) + F(2) = 2 + 1 = 3

**提示：**

- `0 <= n <= 100`

tab:思路

1. **暴力递归：**

原理： 把 f(n) 问题的计算拆分成 f(n−1) 和 f(n−2) 两个子问题的计算，并递归，以 f(0) 和 f(1) 为终止条件。

缺点： 大量重复的递归计算，例如 f(n) 和 f(n−1) 两者向下递归需要 各自计算 f(n−2) 的值。

2. **记忆化递归：**

原理： 在递归法的基础上，新建一个长度为 n 的数组，用于在递归时存储 f(0) 至 f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。

缺点： 记忆化存储需要使用 O(N) 的额外空间。

3. **动态规划：**

原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1) 为转移方程。
从计算效率、空间复杂度上看，动态规划是本题的最佳解法。

tab:代码

```c++
class Solution {
public:
    int fib(int n) {
        int fib_prev_prev = 0; // 初始为fib(0)，此后保存fib(n-2)
        int fib_prev = 1; // 初始为fib(1)，此后保存fib(n-1)
        int sum; // fib(n)
	    if(n==0||n==1)
	        return n;
	    else{
	        while(1<n--){
	            sum = (fib_prev_prev + fib_prev) % 1000000007; // 此时sum = fib(n)
	            fib_prev_prev = fib_prev; // 更新fib(n-2) = fib(n-1)
	            fib_prev = sum; // 更新fib(n-1) = fib(n)
	        }
	        return sum;
	    }
    }
};
```
````
## 01-F2动态规划：最长公共子序列
[LCR 095. 最长公共子序列](https://leetcode.cn/problems/qJnOS7/)
````tab
tab:题目

#中等

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

tab:示例

**示例 1：**

**输入：**text1 = "abcde", text2 = "ace" 
**输出：**3  
**解释：**最长公共子序列是 "ace" ，它的长度为 3 。

**示例 2：**

**输入：**text1 = "abc", text2 = "abc"
**输出：**3
**解释：**最长公共子序列是 "abc" ，它的长度为 3 。

**示例 3：**

**输入：**text1 = "abc", text2 = "def"
**输出：**0
**解释：**两个字符串没有公共子序列，返回 0 。

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

tab:思路
当text1或text2长度为0时，显然lcs=0，假设我们已经知道text1[0:i-1]和text2[0:j-1]这两个字符串的最长公共子序列，当text1和text2都增加一个字符时，会产生三种情况：
1. text1[i] == text2[j]，则最长公共子序列增加1
2. text1[i] != text2[j]，则最长公共子序列仍有可能增加1，例如 text1 = "acb,d", text2 = "ace,b"，虽然text1增加的字符是'd'不等于text2增加的字符'b'，但text2[j] = 'b'可能与text1[0:i-1]新增匹配，使得lcs+1

状态转移方程：
$$
d p[i][j]= \begin{cases}d p[i-1][j-1]+1, & \operatorname{text}_1[i-1]=\operatorname{text}_2[j-1] \\ \max (d p[i-1][j], d p[i][j-1]), & \operatorname{text}_1[i-1] \neq \operatorname{text}_2[j-1]\end{cases}
$$

tab:代码
```c++
#include <iostream>
#include <string>
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.length();
        int m = text2.length();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(text1[i]==text2[j]){
                    dp[i+1][j+1] = 1+dp[i][j];
                }
                else{
                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]);
                }
            }
        }
        return dp[n][m];
    }
};
```
````
# 向量
## 无序向量唯一化稳定版本
```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
struct Element {
  int value;
  int rank;
};
bool compareByValue(const Element &a, const Element &b) {
  return a.value < b.value;
}

bool compareByRank(const Element &a, const Element &b) {
  return a.rank < b.rank;
}

int main() {
  vector<int> arr = {4, 2, 4, 5, 2, 6, 8, 8, 2, 9, 3, 1, 3, 4};
  vector<Element> elements;
  for (size_t i = 0; i < arr.size(); ++i) {
    elements.push_back({arr[i], i});
  }
  cout << "初始的向量的内容：";
  for (Element ele : elements) {
    cout << ele.value << " ";
  }
  // 第一次排序，按值排序
  sort(elements.begin(), elements.end(), compareByValue);
  cout << endl << "排序后的向量的内容：";
  for (Element ele : elements) {
    cout << ele.value << " ";
  }
  //去重
  int i = 0;
  int j = 0;
  while (j < arr.size()) {
    if (elements[i].value != elements[j].value) {
      elements[++i] = elements[j];
    }
    j++;
  }
  int m = j - i - 1; //要删除的元素的个数
  elements.erase(elements.end() - m, elements.end());
  cout << endl << "排序后的去重后的向量的内容：";
  for (Element ele : elements) {
    cout << ele.value << " ";
  }
  //还原向量原本的相对顺序
  sort(elements.begin(), elements.end(), compareByRank);
  cout << endl << "去重后的还保留原本相对顺序的向量的内容：";
  for (Element ele : elements) {
    cout << ele.value << " ";
  }
  return 0;
}
```



# 二叉树
## 二叉树模板类
# 排序
## 02-E 向量-冒泡排序
```c++
// 跳跃版冒泡排序
#include <iostream>
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
    // last用来记录每轮进行交换的最后一个下标
        int high = nums.size() - 1, last;
        // 当一轮结束，数组[last, high]已经全部有序，问题规模缩小为[0, last)
        for (; 0 < high; high = last) {
        // 每轮开始时，last从头开始记录
            for (int i = last = 0; i < high; i++) {
                if (nums[i] > nums[i + 1]) {
                    int temp = nums[i + 1];
                    nums[i + 1] = nums[i];
                    nums[i] = temp;
                    last = i;
                }
            }
        }
        return nums;
    }
};
```
冒泡排序稳定，时间效率 $O(n) \sim O(n^2)$，空间复杂度为 $O(1)$ 
## 02-F1 向量-归并排序
```c++
/* 归并排序 */
void mergeSort(vector<int> &nums, int left, int right) {
    // 终止条件
    if (left >= right)
        return; // 当子数组长度为 1 时终止递归
    // 划分阶段
    int mid = left + (right - left) / 2;    // 计算中点
    mergeSort(nums, left, mid);      // 递归左子数组
    mergeSort(nums, mid + 1, right); // 递归右子数组
    // 合并阶段
    merge(nums, left, mid, right);
}

/* 合并左子数组和右子数组 */
void merge(vector<int> &nums, int left, int mid, int right) {
    // 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]
    // 创建一个临时数组 tmp ，用于存放合并后的结果
    vector<int> tmp(right - left + 1);
    // 初始化左子数组, 右子数组, 临时数组的起始索引
    int i = left, j = mid + 1, k = 0;
    // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j])
            tmp[k++] = nums[i++];
        else
            tmp[k++] = nums[j++];
    }
    // 将左子数组和右子数组的剩余元素复制到临时数组中
    while (i <= mid) {
        tmp[k++] = nums[i++];
    }
    while (j <= right) {
        tmp[k++] = nums[j++];
    }
    // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间
    for (k = 0; k < tmp.size(); k++) {
        nums[left + k] = tmp[k];
    }
}
```
归并排序稳定，时间复杂度为 $\Theta(n\log n)$，空间复杂度为 $O(n)$
