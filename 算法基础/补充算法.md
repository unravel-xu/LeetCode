## 12 对顶堆
用 STL 实现堆
`priority_queue<结构类型> 队列名; `
以一个名为 q 的优先队列为例：
* q.size();//返回 q 里元素个数
* q.empty();//返回 q 是否为空，空则返回 1，否则返回 0
* q.push(k);//在 q 的末尾插入 k
* q.pop();//删掉 q 的第一个元素
* q.top();//返回 q 的第一个元素
* q.back();//返回 q 的末尾元素
```c++
#include <queue>
using namespace std;
// 默认优先级，从大到小
priority_queue<int> q;
// less 从小到大，可简化上述默认
priority_queue<int, vector<int>, less<int> > q;
// greater 从大到小
priority_queue<int, vector<int>, greater<int> > q;
// 传入比较结构体，自定义优先级
struct cmp{
    bool operator ()(int a, int b){    
    //通过传入不同类型来定义不同类型优先级
        return a > b;    //最小值优先
    }
};
priority_queue<int, vector<int>, cmp > q;
// 自定义结构体，自定义优先级
struct node
{
	int priority;
    int value;
    bool operator < (const node & a) const
    {
        return priority < a.priority;
    }
};
priority_queue <node> q;
```

对顶堆可以动态维护一个序列上的第**k**大的数，由一个大根堆和一个小根堆组成，
- 小根堆维护**前k大**的数(包含第k个)
- 大根堆维护**比第k个数小**的数
![](Images/Pasted%20image%2020240823194003.png)
具体操作如下：
1. 插入：若插入元素 $\geq$ 小根堆堆顶元素，则将其插入小根堆，否则将其插入大根堆
2. 维护：当小根堆的大小 > k 时，不断的将小根堆堆顶元素取出并插入大根堆，直到小根堆的大小等于 k；当小根堆的大小 < k 时，不断的将大根堆堆顶元素取出并插入小根堆，直到小根堆的大小等于 k
3. 查询：第 k 大元素就是小根堆堆顶元素
4. 删除：删除第 k 大元素就是删除小根堆堆顶元素